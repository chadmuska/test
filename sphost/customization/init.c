/**************************************************************************
 *
 *       Copyright (c) 2005-2018 by iCatch Technology, Inc.
 *
 *  This software is copyrighted by and is the property of iCatch
 *  Technology, Inc.. All rights are reserved by iCatch Technology, Inc..
 *  This software may only be used in accordance with the corresponding
 *  license agreement. Any unauthorized use, duplication, distribution,
 *  or disclosure of this software is expressly forbidden.
 *
 *  This Copyright notice MUST not be removed or modified without prior
 *  written consent of iCatch Technology, Inc..
 *
 *  iCatch Technology, Inc. reserves the right to modify this software
 *  without notice.
 *
 *  iCatch Technology, Inc.
 *  19-1, Innovation First Road, Science-Based Industrial Park,
 *  Hsin-Chu, Taiwan.
 *                                                                        
 **************************************************************************/

/**
 * \file init.c
 * \brief The initial functions.
 * Variable contents in DRAM are ready after __init.
 * \author Anmin Deng
 */

/**************************************************************************
 *                         H E A D E R   F I L E S                        *
 **************************************************************************/
#include "common.h"

/**************************************************************************
 *                           C O N S T A N T S                            *
 **************************************************************************/
#undef  DBG_INIT_QUART
/*#define DBG_INIT_QUART   1*/

#if DATA_ON_DMEM
#define RAM_START_ADDR ((void *)0xd0000000)
#elif RAM_4GBIT_SUPPORT
#define RAM_START_ADDR ((void *)0x60000000)
#else
#define RAM_START_ADDR ((void *)0xa0000000)
#endif

/**************************************************************************
 *                              M A C R O S                               *
 **************************************************************************/

/**************************************************************************
 *                 E X T E R N A L    R E F E R E N C E S                 *
 **************************************************************************/
extern void QUARTInit(void)       __attribute__ ((section (".boot")));
extern int  QUARTChar(int)        __attribute__ ((section (".boot")));
# if SPCA6350
extern void QUARTXnum(UINT32 n,UINT32 d) __attribute__ ((section (".boot")));
extern void QUARTDump(const void *,UINT32) __attribute__ ((section (".boot")));
extern void QUARTStr(const char *) __attribute__ ((section (".boot")));
#define QUART_NEWLINE    QUARTChar('\n');
# else
extern void QUART(UINT32,UINT32,UINT32) __attribute__ ((section (".boot")));
#define QUARTXnum(n,d)   QUART(n,d,1)
#define QUART_NEWLINE    do {QUARTChar('\r');QUARTChar('\n');} while (0)
# endif

extern UINT32 _bssStart;
extern UINT32 _bssEnd __attribute__ ((section (".bss")));
extern UINT32 _dram_content_lma_start __attribute__ ((section (".rom")));
extern UINT32 _dram_content_vma_start __attribute__ ((section (".text")));

#if SPCA6350
extern UINT32 start  __attribute__((section (".text")));
# if DATA_ON_DMEM
#  define _ETEXT _rodata
# elif ROM_PROGRAM
#  define _ETEXT _dram_content_lma_start
# elif RAM_4GBIT_SUPPORT
#  define _ETEXT _large_ram_etext_kseg0_addr
# else
#  define _ETEXT _data
# endif
extern UINT32 _ETEXT __attribute__((section (".text")));
# if RAM_BOOT
extern UINT32 _erom __attribute__ ((section (".text")));
extern UINT32 _text __attribute__ ((section (".text")));
# elif ROM_PROGRAM && !CPU_CORE_USE_ROM_INT_VECTOR
extern UINT32 _except __attribute__ ((section (".text")));
extern UINT32 _eexcept __attribute__ ((section (".text")));
# endif

extern UINT32 _bottomOfHeap __attribute__ ((section (".bss")));
extern void __memUnusedSet(void *p)  __attribute__ ((section (".boot")));
extern void __heapEndSet(void *p)    __attribute__ ((section (".boot")));

# if RAM_BOOT
#  define cpuCacheAllSyncI     boot_cpuCacheAllSyncI
#  define cpuDCacheAllFlush    boot_cpuDCacheAllFlush
#  define cpuDCacheFlush       boot_cpuDCacheFlush
#  define cpuCacheSyncI        boot_cpuCacheSyncI
extern void cpuCacheAllSyncI(void)   __attribute__ ((section (".boot")));
extern void cpuDCacheAllFlush(void)  __attribute__ ((section (".boot")));
extern void cpuDCacheFlush(void *,UINT32)  __attribute__ ((section (".boot")));
extern void cpuCacheSyncI(void *,UINT32)   __attribute__ ((section (".boot")));
# else  /*#if RAM_BOOT*/
extern void cpuCacheAllSyncI(void)   __attribute__ ((section (".text")));
extern void cpuDCacheAllFlush(void)  __attribute__ ((section (".text")));
extern void cpuDCacheFlush(void *,UINT32)  __attribute__ ((section (".text")));
extern void cpuCacheSyncI(void *,UINT32)   __attribute__ ((section (".text")));
# endif /*#if RAM_BOOT*/

#else  /*#if SPCA6350*/

extern void addrInit(void);
extern void _exceptVect(void);

/**************************************************************************
 *                          D A T A    T Y P E S                          *
 **************************************************************************/
typedef struct memProfile_s {
	void *pdataLma;
	void *pdataVma;
	void *pheapStart;
	void *pheapEnd;
} memProfile_t;

/**************************************************************************
 *                         G L O B A L    D A T A                         *
 **************************************************************************/
memProfile_t memProfile __attribute__ ((section (".sbss")));
#endif /*#if SPCA6350*/

/**************************************************************************
 *               F U N C T I O N    D E C L A R A T I O N S               *
 **************************************************************************/
void   __init(void)       __attribute__ ((section (".boot")));

#if !DATA_ON_DMEM
static UINT32 dramSizeTest(void) __attribute__ ((section (".boot")));

/**
 * \brief Check the dram size
 *
 * When we use nand, the dram size is specified in dram parameter. Otherwise,
 * we auto check the dram size here. (Typically for fpga verification)
 */
UINT32
dramSizeTest(
	void
)
{
	UINT32 memSize;/*unit:byte*/
	volatile UINT8  *preg = (UINT8 *)0xb0007050;

	/* DRAM size undetermined yet */
# ifndef RAM_PROGRAM
	volatile UINT32 * const pstart = (UINT32 *)RAM_START_ADDR;
	volatile UINT32 *pread;
	UINT32 j;
#  if SPCA5310
#   if SPCA6350 && RAM_4GBIT_SUPPORT
	UINT32 i = 0x40;
	UINT32 bits = 27/*unit:double-word*/;
	memSize = 512 * 1024 * 1024;/*unit:byte*/
#   else  /*if SPCA6350 && RAM_4GBIT_SUPPORT*/
	UINT32 i = 0x20;
	UINT32 bits = 26/*unit:double-word*/;
	memSize = 256 * 1024 * 1024;/*unit:byte*/
#   endif /*if SPCA6350 && RAM_4GBIT_SUPPORT*/
#  else /*SPCA5210*/
	UINT32 i = 6;
	UINT32 bits = 25;
	memSize = 128 * 1024 * 1024;
#  endif /*#if SPCA5310*/

try_again:
#  if SPCA6350
	while ( i >= 8 ) {
		*preg = (*preg & 0xc3) | (i == 0x40 ? 4 : i);
#  elif SPCA5310 /*#if SPCA6350*/
	while ( i >= 1 ) {
		*preg = (*preg & 0xc0) | i;
#  else  /*SPCA5210*/
	while ( i >= 3 ) {
		*preg = (*preg & 0xf8) | i;
#  endif /*if SPCA6350*/

		for ( j = 0; j < bits; j++ ) {
			pread = pstart + (1 << j);
			*pread = 0x55aaaa55;
		}
		*pstart = 0xf0f0f0f0;
		for ( j = 0; j < bits; j++ ) {
			pread = pstart + (1 << j);
			if ( *pread == 0xf0f0f0f0 ) {
#  if SPCA5310
				i=i>>1;
#  else  /*SPCA5210*/
				i--;
#  endif /*if SPCA5310*/
				bits--;
				memSize = memSize >> 1;
				goto try_again;
			}
		}
		break;
	}
# else  /*#ifndef RAM_PROGRAM*/

	/* DRAM size determined in boot code earlier */
#  if SPCA6350
	unsigned sizecode = *preg & 0x3c;
#   if RAM_4GBIT_SUPPORT
	if (sizecode == 4) sizecode = 0x40;
#   else  /*if RAM_4GBIT_SUPPORT*/
	if (sizecode == 4) sizecode = 0x20;
#   endif /*if RAM_4GBIT_SUPPORT*/
	memSize = sizecode * 8 * 1024 * 1024;
#  elif SPCA5310  /*#if SPCA6350*/
	memSize = (UINT32)(*preg & 0x3f) * 8 * 1024 * 1024;
#  else /*SPCA5210*/
	memSize = (2 * 1024 * 1024) << (UINT32)(*preg & 0x07);
#  endif /*if SPCA6350*/

# endif /*#ifndef RAM_PROGRAM*/


# if !SPCA6350 /*spca6350 revoking memProfile*/
#  ifndef RAM_PROGRAM
	addrInit();
#  endif
# endif /*#if !SPCA6350*/

/* emulating limited memory in realkit */
# if FORCE_DRAM_SMALL_SIZE
	if ( memSize > FORCE_DRAM_SMALL_SIZE ) {
		memSize = FORCE_DRAM_SMALL_SIZE;
#  if SPCA6350
		if (memSize > 256*1024*1024) memSize = 256*1024*1024;
		/* memSize = (UINT32)(*preg & 0x38) * 8 * 1024 * 1024; */
		*preg = (*preg & 0xc3) | memSize / (8 * 1024 * 1024);
#  elif !SPCA7002 && SPCA5310
		/* memSize = (UINT32)(*preg & 0x3f) * 8 * 1024 * 1024; */
		*preg = (*preg & 0xc0) | memSize / (8 * 1024 * 1024);
#  else
		/* memSize = (2 * 1024 * 1024) << (UINT32)(*preg & 0x07); */
		UINT32 i, s;
		for ( i=0, s = (memSize - 1) / (2 * 1024 * 1024);
				s != 0; s >>= 1, ++i ) ;
		*preg = (*preg & 0xf8) | i;
#  endif
	}
# endif

	return memSize;
}

#endif /*#if !DATA_ON_DMEM*/

#if !SPCA6350 && !defined(RAM_PROGRAM) && !defined(FPGA)
#if SPCA6330
const UINT8 dramParamData[] __attribute__ ((section (".bootParam"))) = {
#ifdef DDR2
	#if 1 /* BGA/Socket 135MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x33, 0x00, 0x08, 0xFD, 0x6A, 0x70, 0xFF, 0x6B,
	0x70, 0x0F, 0x80, 0x70, 0x01, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70,
	0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00,
	0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91,
	0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70,
	0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0xD0, 0x53, 0x70, 0xF0,
	0x54, 0x70, 0x06, 0x55, 0x70, 0x04, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x16, 0x59,
	0x70, 0x13, 0x5A, 0x70, 0x06, 0x5B, 0x70, 0x07, 0x5D, 0x70, 0x11, 0x5E, 0x70, 0x0B, 0x5F, 0x70,
	0x11, 0x64, 0x70, 0x30, 0x65, 0x70, 0x05, 0x66, 0x70, 0x0A, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00,
	0x69, 0x70, 0x00, 0x73, 0x70, 0x04, 0x74, 0x70, 0x07, 0x75, 0x70, 0x07, 0x81, 0x70, 0x0B, 0xE6,
	0x70, 0x02, 0x51, 0x70, 0x04,
	#elif 0 /* BGA 165MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x37, 0x00, 0xF6, 0x00, 0x89, 0x00, 0x04, 0x7A,
	0x00, 0xDC, 0x7B, 0x00, 0x00, 0x8E, 0x00, 0x0D, 0x6A, 0x70, 0xFF, 0x6B, 0x70, 0x0F, 0x80, 0x70,
	0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A,
	0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D,
	0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70,
	0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00,
	0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0xD0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0xF0, 0x55,
	0x70, 0x04, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x16, 0x59, 0x70, 0x17, 0x5A, 0x70,
	0x08, 0x5B, 0x70, 0x09, 0x5D, 0x70, 0x15, 0x5E, 0x70, 0x0B, 0x5F, 0x70, 0x11, 0x64, 0x70, 0x30,
	0x65, 0x70, 0x05, 0x66, 0x70, 0x0A, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73,
	0x70, 0x04, 0x74, 0x70, 0x07, 0x75, 0x70, 0x07, 0x81, 0x70, 0x0B, 0xE6, 0x70, 0x02, 0x51, 0x70,
	0x04,
	#elif 0 /* BGA 189MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x38, 0x00, 0x6F, 0x01, 0x89, 0x00, 0x05, 0x8A,
	0x00, 0x08, 0x7A, 0x00, 0xFC, 0x7B, 0x00, 0x00, 0x8E, 0x00, 0x0F, 0x6A, 0x70, 0xFF, 0x6B, 0x70,
	0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00,
	0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C,
	0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70,
	0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00,
	0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0xD0, 0x53, 0x70, 0xF0, 0x54,
	0x70, 0xAB, 0x55, 0x70, 0x05, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x16, 0x59, 0x70,
	0x1A, 0x5A, 0x70, 0x09, 0x5B, 0x70, 0x0A, 0x5D, 0x70, 0x18, 0x5E, 0x70, 0x0B, 0x5F, 0x70, 0x11,
	0x64, 0x70, 0x30, 0x65, 0x70, 0x05, 0x66, 0x70, 0x0A, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69,
	0x70, 0x00, 0x73, 0x70, 0x04, 0x74, 0x70, 0x07, 0x75, 0x70, 0x07, 0x81, 0x70, 0x0B, 0xE6, 0x70,
	0x02, 0x51, 0x70, 0x04,
	#elif 0 /* BGA 222.75MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x38, 0x00, 0xCA, 0x00, 0x89, 0x00, 0x06, 0x8A,
	0x00, 0x09, 0x7A, 0x00, 0x29, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x12, 0x6A, 0x70, 0xFF, 0x6B, 0x70,
	0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00,
	0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C,
	0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70,
	0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00,
	0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0xD0, 0x53, 0x70, 0xF0, 0x54,
	0x70, 0xB2, 0x55, 0x70, 0x06, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x16, 0x59, 0x70,
	0x1F, 0x5A, 0x70, 0x0B, 0x5B, 0x70, 0x0C, 0x5D, 0x70, 0x1C, 0x5E, 0x70, 0x0C, 0x5F, 0x70, 0x21,
	0x64, 0x70, 0x30, 0x65, 0x70, 0x07, 0x66, 0x70, 0x0A, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69,
	0x70, 0x00, 0x73, 0x70, 0x04, 0x74, 0x70, 0x07, 0x75, 0x70, 0x07, 0x81, 0x70, 0x0B, 0xE6, 0x70,
	0x02, 0x51, 0x70, 0x04,
	#elif 0 /* BGA 243MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3A, 0x00, 0xAE, 0x01, 0x89, 0x00, 0x06, 0x8A,
	0x00, 0x0A, 0x85, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00, 0x44, 0x7B, 0x00, 0x01, 0x8E, 0x00,
	0x13, 0x6A, 0x70, 0xFF, 0x6B, 0x70, 0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00,
	0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A,
	0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70,
	0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00,
	0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50,
	0x70, 0xD0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x50, 0x55, 0x70, 0x07, 0x56, 0x70, 0x03, 0x57, 0x70,
	0x41, 0x58, 0x70, 0x16, 0x59, 0x70, 0x22, 0x5A, 0x70, 0x0C, 0x5B, 0x70, 0x0D, 0x5D, 0x70, 0x1E,
	0x5E, 0x70, 0x0C, 0x5F, 0x70, 0x21, 0x64, 0x70, 0x30, 0x65, 0x70, 0x07, 0x66, 0x70, 0x0A, 0x67,
	0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x04, 0x74, 0x70, 0x07, 0x75, 0x70,
	0x07, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x04,
	#elif 0 /* BGA 267MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3A, 0x00, 0x9F, 0x01, 0x89, 0x00, 0x07, 0x8A,
	0x00, 0x0B, 0x85, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00, 0x64, 0x7B, 0x00, 0x01, 0x8E, 0x00,
	0x15, 0x6A, 0x70, 0xFF, 0x6B, 0x70, 0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00,
	0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A,
	0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70,
	0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00,
	0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50,
	0x70, 0xD0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0B, 0x55, 0x70, 0x08, 0x56, 0x70, 0x03, 0x57, 0x70,
	0x41, 0x58, 0x70, 0x18, 0x59, 0x70, 0x25, 0x5A, 0x70, 0x0D, 0x5B, 0x70, 0x0F, 0x5D, 0x70, 0x22,
	0x5E, 0x70, 0x0E, 0x5F, 0x70, 0x21, 0x64, 0x70, 0x30, 0x65, 0x70, 0x09, 0x66, 0x70, 0x0A, 0x67,
	0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x04, 0x74, 0x70, 0x08, 0x75, 0x70,
	0x07, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x04,
	#elif 0 /* BGA 297MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3C, 0x00, 0x1B, 0x04, 0x89, 0x00, 0x08, 0x8A,
	0x00, 0x11, 0x92, 0x00, 0x17, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00,
	0x8C, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x18, 0x6A, 0x70, 0xFF, 0x6B, 0x70, 0x0F, 0x80, 0x70, 0x00,
	0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88,
	0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70,
	0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00,
	0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC,
	0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0xD0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0xF5, 0x55, 0x70,
	0x08, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x19, 0x59, 0x70, 0x29, 0x5A, 0x70, 0x0E,
	0x5B, 0x70, 0x10, 0x5D, 0x70, 0x25, 0x5E, 0x70, 0x10, 0x5F, 0x70, 0x21, 0x64, 0x70, 0x40, 0x65,
	0x70, 0x09, 0x66, 0x70, 0x12, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70,
	0x06, 0x74, 0x70, 0x09, 0x75, 0x70, 0x07, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x04,
	#elif 0 /* BGA 333MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3F, 0x00, 0x38, 0x05, 0x89, 0x00, 0x09, 0x8A,
	0x00, 0x13, 0x92, 0x00, 0x17, 0x83, 0x00, 0x04, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x91, 0x00,
	0x04, 0x93, 0x00, 0x04, 0x94, 0x00, 0x05, 0x7A, 0x00, 0xBC, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x1B,
	0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0A, 0x80, 0x70, 0x01, 0x82, 0x70, 0x06, 0x84, 0x70, 0x00, 0x85,
	0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70,
	0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00,
	0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95,
	0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70,
	0xD0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0E, 0x55, 0x70, 0x0A, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41,
	0x58, 0x70, 0x19, 0x59, 0x70, 0x2E, 0x5A, 0x70, 0x1F, 0x5B, 0x70, 0x12, 0x5D, 0x70, 0x2A, 0x5E,
	0x70, 0x10, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x40, 0x65, 0x70, 0x09, 0x66, 0x70, 0x12, 0x67, 0x70,
	0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x07, 0x74, 0x70, 0x09, 0x75, 0x70, 0x08,
	0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x04,
	#elif 0 /* BGA 360MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3F, 0x00, 0x4A, 0x06, 0x89, 0x00, 0x0A, 0x8A,
	0x00, 0x15, 0x92, 0x00, 0x1D, 0x83, 0x00, 0x04, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x91, 0x00,
	0x04, 0x93, 0x00, 0x04, 0x94, 0x00, 0x05, 0x7A, 0x00, 0xE0, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x1D,
	0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0E, 0x80, 0x70, 0x01, 0x82, 0x70, 0x06, 0x84, 0x70, 0x00, 0x85,
	0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70,
	0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00,
	0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95,
	0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70,
	0xD0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0xE1, 0x55, 0x70, 0x0A, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41,
	0x58, 0x70, 0x19, 0x59, 0x70, 0x32, 0x5A, 0x70, 0x1F, 0x5B, 0x70, 0x13, 0x5D, 0x70, 0x2D, 0x5E,
	0x70, 0x11, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x40, 0x65, 0x70, 0x0B, 0x66, 0x70, 0x12, 0x67, 0x70,
	0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x07, 0x74, 0x70, 0x09, 0x75, 0x70, 0x08,
	0x81, 0x70, 0x0A, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x04,
	#endif
#elif defined(DDR3)
	#if 0 /* BGA 243MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3A, 0x00, 0x85, 0x01, 0x89, 0x00, 0x06, 0x8A,
	0x00, 0x0A, 0x85, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00, 0x44, 0x7B, 0x00, 0x01, 0x8E, 0x00,
	0x13, 0x6A, 0x70, 0xFE, 0x6B, 0x70, 0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00,
	0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A,
	0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70,
	0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00,
	0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50,
	0x70, 0x90, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x50, 0x55, 0x70, 0x07, 0x56, 0x70, 0x03, 0x57, 0x70,
	0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x1E, 0x5A, 0x70, 0x0C, 0x5B, 0x70, 0x0C, 0x5D, 0x70, 0x1A,
	0x5E, 0x70, 0x12, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x03, 0x66, 0x70, 0x12, 0x67,
	0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x08, 0x74, 0x70, 0x0C, 0x75, 0x70,
	0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* BGA 267MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3A, 0x00, 0x6E, 0x01, 0x89, 0x00, 0x07, 0x8A,
	0x00, 0x0B, 0x85, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00, 0x64, 0x7B, 0x00, 0x01, 0x8E, 0x00,
	0x15, 0x6A, 0x70, 0xFE, 0x6B, 0x70, 0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00,
	0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A,
	0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70,
	0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00,
	0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50,
	0x70, 0x90, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0B, 0x55, 0x70, 0x08, 0x56, 0x70, 0x03, 0x57, 0x70,
	0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x21, 0x5A, 0x70, 0x0D, 0x5B, 0x70, 0x0D, 0x5D, 0x70, 0x1D,
	0x5E, 0x70, 0x13, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x03, 0x66, 0x70, 0x12, 0x67,
	0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x08, 0x74, 0x70, 0x0C, 0x75, 0x70,
	0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* BGA 297MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3C, 0x00, 0xBA, 0x03, 0x89, 0x00, 0x08, 0x8A,
	0x00, 0x11, 0x92, 0x00, 0x17, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00,
	0x8C, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x18, 0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0E, 0x80, 0x70, 0x00,
	0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88,
	0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70,
	0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00,
	0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC,
	0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0x90, 0x53, 0x70, 0xF0, 0x54, 0x70, 0xF5, 0x55, 0x70,
	0x08, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x24, 0x5A, 0x70, 0x0E,
	0x5B, 0x70, 0x0E, 0x5D, 0x70, 0x20, 0x5E, 0x70, 0x13, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65,
	0x70, 0x03, 0x66, 0x70, 0x12, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70,
	0x08, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 1 /* BGA 300MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3C, 0x00, 0xD7, 0x02, 0x89, 0x00, 0x08, 0x8A,
	0x00, 0x11, 0x92, 0x00, 0x17, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00,
	0x90, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x18, 0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0E, 0x80, 0x70, 0x00,
	0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88,
	0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70,
	0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00,
	0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC,
	0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0x90, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0D, 0x55, 0x70,
	0x09, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x24, 0x5A, 0x70, 0x0E,
	0x5B, 0x70, 0x0E, 0x5D, 0x70, 0x20, 0x5E, 0x70, 0x13, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65,
	0x70, 0x03, 0x66, 0x70, 0x12, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70,
	0x08, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* BGA 333MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3F, 0x00, 0xDD, 0x04, 0x89, 0x00, 0x09, 0x8A,
	0x00, 0x13, 0x92, 0x00, 0x17, 0x83, 0x00, 0x04, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x91, 0x00,
	0x04, 0x93, 0x00, 0x04, 0x94, 0x00, 0x05, 0x7A, 0x00, 0xBC, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x1B,
	0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0E, 0x80, 0x70, 0x01, 0x82, 0x70, 0x06, 0x84, 0x70, 0x00, 0x85,
	0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70,
	0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00,
	0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95,
	0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70,
	0x90, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0E, 0x55, 0x70, 0x0A, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41,
	0x58, 0x70, 0x3A, 0x59, 0x70, 0x28, 0x5A, 0x70, 0x1F, 0x5B, 0x70, 0x10, 0x5D, 0x70, 0x24, 0x5E,
	0x70, 0x14, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x03, 0x66, 0x70, 0x12, 0x67, 0x70,
	0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x09, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x07,
	0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* BGA 360MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3F, 0x00, 0xA7, 0x05, 0x89, 0x00, 0x0A, 0x8A,
	0x00, 0x15, 0x92, 0x00, 0x1D, 0x83, 0x00, 0x04, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x91, 0x00,
	0x04, 0x93, 0x00, 0x04, 0x94, 0x00, 0x05, 0x7A, 0x00, 0xE0, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x1D,
	0x6A, 0x70, 0xAE, 0x6B, 0x70, 0x0A, 0x80, 0x70, 0x01, 0x82, 0x70, 0x06, 0x84, 0x70, 0x00, 0x85,
	0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70,
	0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00,
	0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95,
	0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70,
	0x90, 0x53, 0x70, 0xF0, 0x54, 0x70, 0xE1, 0x55, 0x70, 0x0A, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41,
	0x58, 0x70, 0x3A, 0x59, 0x70, 0x2C, 0x5A, 0x70, 0x1F, 0x5B, 0x70, 0x11, 0x5D, 0x70, 0x27, 0x5E,
	0x70, 0x15, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x05, 0x66, 0x70, 0x12, 0x67, 0x70,
	0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x09, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x07,
	0x81, 0x70, 0x0A, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* 2G 243MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3A, 0x00, 0x95, 0x01, 0x89, 0x00, 0x06, 0x8A,
	0x00, 0x0A, 0x85, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00, 0x44, 0x7B, 0x00, 0x01, 0x8E, 0x00,
	0x13, 0x6A, 0x70, 0xFE, 0x6B, 0x70, 0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00,
	0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A,
	0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70,
	0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00,
	0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50,
	0x70, 0xA0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x50, 0x55, 0x70, 0x07, 0x56, 0x70, 0x03, 0x57, 0x70,
	0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x1E, 0x5A, 0x70, 0x0C, 0x5B, 0x70, 0x0C, 0x5D, 0x70, 0x1A,
	0x5E, 0x70, 0x12, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x03, 0x66, 0x70, 0x12, 0x67,
	0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x08, 0x74, 0x70, 0x0C, 0x75, 0x70,
	0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* 2G 267MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3A, 0x00, 0x7E, 0x01, 0x89, 0x00, 0x07, 0x8A,
	0x00, 0x0B, 0x85, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00, 0x64, 0x7B, 0x00, 0x01, 0x8E, 0x00,
	0x15, 0x6A, 0x70, 0xFE, 0x6B, 0x70, 0x0F, 0x80, 0x70, 0x00, 0x82, 0x70, 0x07, 0x84, 0x70, 0x00,
	0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A,
	0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70,
	0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00,
	0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50,
	0x70, 0xA0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0B, 0x55, 0x70, 0x08, 0x56, 0x70, 0x03, 0x57, 0x70,
	0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x21, 0x5A, 0x70, 0x0D, 0x5B, 0x70, 0x0D, 0x5D, 0x70, 0x1D,
	0x5E, 0x70, 0x13, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x03, 0x66, 0x70, 0x12, 0x67,
	0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x08, 0x74, 0x70, 0x0C, 0x75, 0x70,
	0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* 2G 297MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3C, 0x00, 0xCA, 0x03, 0x89, 0x00, 0x08, 0x8A,
	0x00, 0x11, 0x92, 0x00, 0x17, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00,
	0x8C, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x18, 0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0E, 0x80, 0x70, 0x00,
	0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88,
	0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70,
	0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00,
	0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC,
	0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0xA0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0xF5, 0x55, 0x70,
	0x08, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x24, 0x5A, 0x70, 0x0E,
	0x5B, 0x70, 0x0E, 0x5D, 0x70, 0x20, 0x5E, 0x70, 0x13, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65,
	0x70, 0x03, 0x66, 0x70, 0x12, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70,
	0x08, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* 2G 300MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3C, 0x00, 0xE7, 0x02, 0x89, 0x00, 0x08, 0x8A,
	0x00, 0x11, 0x92, 0x00, 0x17, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x94, 0x00, 0x05, 0x7A, 0x00,
	0x90, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x18, 0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0E, 0x80, 0x70, 0x00,
	0x82, 0x70, 0x07, 0x84, 0x70, 0x00, 0x85, 0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88,
	0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70, 0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70,
	0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00, 0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00,
	0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95, 0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC,
	0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70, 0xA0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0D, 0x55, 0x70,
	0x09, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41, 0x58, 0x70, 0x39, 0x59, 0x70, 0x24, 0x5A, 0x70, 0x0E,
	0x5B, 0x70, 0x0E, 0x5D, 0x70, 0x20, 0x5E, 0x70, 0x13, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65,
	0x70, 0x03, 0x66, 0x70, 0x12, 0x67, 0x70, 0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70,
	0x08, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x06, 0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* 2G 333MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3F, 0x00, 0xED, 0x04, 0x89, 0x00, 0x09, 0x8A,
	0x00, 0x13, 0x92, 0x00, 0x17, 0x83, 0x00, 0x04, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x91, 0x00,
	0x04, 0x93, 0x00, 0x04, 0x94, 0x00, 0x05, 0x7A, 0x00, 0xBC, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x1B,
	0x6A, 0x70, 0xEE, 0x6B, 0x70, 0x0E, 0x80, 0x70, 0x01, 0x82, 0x70, 0x06, 0x84, 0x70, 0x00, 0x85,
	0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70,
	0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00,
	0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95,
	0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70,
	0xA0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0x0E, 0x55, 0x70, 0x0A, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41,
	0x58, 0x70, 0x3A, 0x59, 0x70, 0x28, 0x5A, 0x70, 0x1F, 0x5B, 0x70, 0x10, 0x5D, 0x70, 0x24, 0x5E,
	0x70, 0x14, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x03, 0x66, 0x70, 0x12, 0x67, 0x70,
	0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x09, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x07,
	0x81, 0x70, 0x09, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#elif 0 /* 2G 360MHz */
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x31, 0x3F, 0x00, 0xB7, 0x05, 0x89, 0x00, 0x0A, 0x8A,
	0x00, 0x15, 0x92, 0x00, 0x1D, 0x83, 0x00, 0x04, 0x85, 0x00, 0x05, 0x8B, 0x00, 0x05, 0x91, 0x00,
	0x04, 0x93, 0x00, 0x04, 0x94, 0x00, 0x05, 0x7A, 0x00, 0xE0, 0x7B, 0x00, 0x01, 0x8E, 0x00, 0x1D,
	0x6A, 0x70, 0xAE, 0x6B, 0x70, 0x0A, 0x80, 0x70, 0x01, 0x82, 0x70, 0x06, 0x84, 0x70, 0x00, 0x85,
	0x70, 0x00, 0x86, 0x70, 0x00, 0x87, 0x70, 0x0A, 0x88, 0x70, 0x00, 0x89, 0x70, 0x00, 0x8A, 0x70,
	0x00, 0x8B, 0x70, 0x00, 0x8C, 0x70, 0x00, 0x8D, 0x70, 0x00, 0x8E, 0x70, 0x00, 0x8F, 0x70, 0x00,
	0x90, 0x70, 0x00, 0x91, 0x70, 0x00, 0x92, 0x70, 0x00, 0x93, 0x70, 0x00, 0x94, 0x70, 0x00, 0x95,
	0x70, 0x00, 0x96, 0x70, 0x00, 0x97, 0x70, 0x00, 0xDC, 0x00, 0x00, 0x20, 0x71, 0x40, 0x50, 0x70,
	0xA0, 0x53, 0x70, 0xF0, 0x54, 0x70, 0xE1, 0x55, 0x70, 0x0A, 0x56, 0x70, 0x03, 0x57, 0x70, 0x41,
	0x58, 0x70, 0x3A, 0x59, 0x70, 0x2C, 0x5A, 0x70, 0x1F, 0x5B, 0x70, 0x11, 0x5D, 0x70, 0x27, 0x5E,
	0x70, 0x15, 0x5F, 0x70, 0x31, 0x64, 0x70, 0x10, 0x65, 0x70, 0x05, 0x66, 0x70, 0x12, 0x67, 0x70,
	0x00, 0x68, 0x70, 0x00, 0x69, 0x70, 0x00, 0x73, 0x70, 0x09, 0x74, 0x70, 0x0C, 0x75, 0x70, 0x07,
	0x81, 0x70, 0x0A, 0xE6, 0x70, 0x02, 0x51, 0x70, 0x00,
	#endif
#else
#error both the DDR2 and DDR3 are undefined.
#endif
};
#elif SPCA5330
const UINT8 dramParamData[] __attribute__ ((section (".bootParam"))) = {
	0x44, 0x52, 0x41, 0x4D, 0x50, 0x41, 0x52, 0x41, 0x2C, 0x00, 0xCE, 0xEC, 0x6A, 0x70, 0xFF, 0x00,
	0x6B, 0x70, 0x0B, 0x00, 0x80, 0x70, 0x00, 0x00, 0x82, 0x70, 0x09, 0x00, 0x84, 0x70, 0xAA, 0x00,
	0x85, 0x70, 0xAA, 0x00, 0x86, 0x70, 0xAA, 0x00, 0x87, 0x70, 0x0A, 0x00, 0x88, 0x70, 0xAA, 0x00,
	0x89, 0x70, 0xAA, 0x00, 0x8A, 0x70, 0xAA, 0x00, 0x8B, 0x70, 0xAA, 0x00, 0x8C, 0x70, 0x00, 0x00,
	0x8D, 0x70, 0x00, 0x00, 0x8E, 0x70, 0x00, 0x00, 0x8F, 0x70, 0x00, 0x00, 0xDC, 0x00, 0x00, 0x00,
	0x20, 0x71, 0x40, 0x00, 0x50, 0x70, 0xD0, 0x00, 0x53, 0x70, 0x30, 0x00, 0x54, 0x70, 0x06, 0x00,
	0x55, 0x70, 0x04, 0x00, 0x56, 0x70, 0x03, 0x00, 0x57, 0x70, 0x41, 0x00, 0x58, 0x70, 0x15, 0x00,
	0x59, 0x70, 0x13, 0x00, 0x5A, 0x70, 0x06, 0x00, 0x5B, 0x70, 0x07, 0x00, 0x5D, 0x70, 0x11, 0x00,
	0x5E, 0x70, 0x0A, 0x00, 0x5F, 0x70, 0x11, 0x00, 0x64, 0x70, 0x30, 0x00, 0x65, 0x70, 0x05, 0x00,
	0x66, 0x70, 0x08, 0x00, 0x67, 0x70, 0x00, 0x00, 0x68, 0x70, 0x00, 0x00, 0x69, 0x70, 0x00, 0x00,
	0x73, 0x70, 0x04, 0x00, 0x74, 0x70, 0x07, 0x00, 0x75, 0x70, 0x07, 0x00, 0x81, 0x70, 0x0B, 0x00,
	0x83, 0x70, 0x00, 0x00, 0xE6, 0x70, 0x02, 0x00, 0x51, 0x70, 0x04, 0x00, 
};
#else
#error Both SPCA5330 and SPCA6330 are not defined.
#endif /* #elif SPCA5330 */

/**
 * \brief Fill the dram parameter for evb+romter
 *
 * In FPGA, we don't have to set the dram parameter.
 * In evb, if we use nand, the dram parameter is set by boot code.
 * Other cases - ram=1 or rom=1 that needs the romter, we have to set the
 * dram paramter here!
 */
static void
dramParam(
	void
)
{
	UINT32 i;
	UINT32 num;
	UINT32 sum, cks;
	
	UINT8 *ptr;
	
	UINT8 *pparam = dramParamData;
	num = *((UINT16 *)(pparam + 8));
	cks = *((UINT16 *)(pparam + 10));
	sum = 0;
	ptr = pparam + 12;
	for (i = 0; i < num; i++) {
		UINT32 offset, value;
		volatile UINT8 *paddr;
		#if SPCA6330
		offset = *ptr | (*(ptr+1) << 8);
		value = *(ptr + 2);
		ptr += 3;
		#else
		offset = *((UINT16 *)ptr);
		value = *((UINT16 *)(ptr+2));
		ptr += 4;
		#endif
		paddr = (volatile UINT8 *)(0xb0000000 + offset);
		*paddr = value;
		sum += offset;
		sum += value;
#if DBG_INIT_QUART
		QUARTXnum(offset, 4);
		QUARTChar(' ');
		QUARTXnum(value, 4);
		QUARTChar(' ');
		QUARTXnum(sum, 4);
		QUART_NEWLINE
#endif
	}
	while(!(*((UINT8 *)0xb00070f0) & 0x02));
	for(i=0;i<100000;i++);
	for(i=0;i<100000;i++);
	for(i=0;i<100000;i++);
	if ((UINT16)cks != (UINT16)sum) {
		QUARTChar('F');
		QUARTXnum(sum, 4);
	}
}
#endif /* #if !SPCA6350 && !defined(RAM_PROGRAM) && !defined(FPGA) */


/** low level initialization function */
void
__init(
	void
)
{
#ifndef RAM_PROGRAM
	UINT32 *src;
#endif
#if !defined(RAM_PROGRAM) || !MULTI_BOOT_STAGE
	UINT32 *dst;
#endif
#if !DATA_ON_DMEM
	UINT32 memSize;
#endif /*#if !DATA_ON_DMEM*/
#if SPCA6350
	void *memUnused, *pheapEnd;
#endif /*#if SPCA6350*/

	/* Enable Audio PLL */
#if SPCA5330
	* ((volatile UINT8 *)0xb00000D0) = 0x01;
#else
	* ((volatile UINT8 *)0xb0000074) = 0x01;
#endif

#if !SPCA6350 && !defined(RAM_PROGRAM) && !defined(FPGA)
  	dramParam();
#endif


#if !DATA_ON_DMEM
	memSize = dramSizeTest();
#endif /*#if !DATA_ON_DMEM*/

	/* Load the instructions or data onto DRAM */
#ifndef RAM_PROGRAM
# if RAM_4GBIT_SUPPORT
	UINT32 * const pimgend = (UINT32 *)((UINT32)&_bssStart + 0x40000000);
# else
	UINT32 * const pimgend = &_bssStart;
# endif
	src = &_dram_content_lma_start;
	dst = &_dram_content_vma_start;

# if !defined(FPGA) && defined(SPCA6330)
	UINT32 sum = 0;
# endif

# if SPCA6350 && RAM_BOOT
	/*to support backdoor (and hence multiboot) in minihost "make ram=1"*/
#  define BKDOOR_SIZE_LIMIT  (16 * 1024)   /*block size 16kB*/
#  define BKDOOR_ENTRY_ADDR  ((void (*)(void))0x80000120)
#  define BADDR_DRAM_TEXT_START_CACHE   ((void *)0x80000000)

	UINT32 *pend;
	if ((UINT8*)BADDR_DRAM_TEXT_START_CACHE + BKDOOR_SIZE_LIMIT < pimgend)
		pend = (UINT8*)BADDR_DRAM_TEXT_START_CACHE + BKDOOR_SIZE_LIMIT;
		pend = pimgend;

	while ( dst < pend ) {
#  if !defined(FPGA) && SPCA6330
		sum += *src;
#  endif
		*dst = *src;
		dst++;
		src++;
	}

	cpuCacheSyncI(BADDR_DRAM_TEXT_START_CACHE, BKDOOR_SIZE_LIMIT);

	void (* const fp)(void) = BKDOOR_ENTRY_ADDR;
	fp();

	/*skip next if bkdoor block size >= image size to copy*/
	if (pend != pimgend)

#  undef  BKDOOR_SIZE_LIMIT
#  undef  BKDOOR_ENTRY_ADDR
#  undef  BADDR_DRAM_TEXT_START_CACHE

# endif /*#if SPCA6350 && RAM_BOOT*/
	while ( dst < pimgend ) {
# if !defined(FPGA) && defined(SPCA6330)
		sum += *src;
# endif
		*dst = *src;
		dst++;
		src++;
	}

	QUARTInit();

#if RAM_BOOT
	UINT32 *srctmp, *dsttmp;
	srctmp = &_dram_content_lma_start;
	dsttmp = (UINT32 *)((UINT32)&_dram_content_vma_start | 0x20000000);

	while ( dsttmp < (UINT32 *)((UINT32)pimgend | 0x20000000) ) {
    	UINT32 vsrc, vdst;
    	vsrc = *srctmp;
    	vdst = *dsttmp;
		if (vsrc != vdst) {
			QUARTXnum((UINT32)srctmp, 8);
			QUARTChar(' ');
			QUARTXnum(*srctmp, 8);
			QUARTChar(' ');
			QUARTXnum(vsrc, 8);
			QUARTChar(' ');
			QUARTXnum((UINT32)dsttmp, 8);
			QUARTChar(':');
			QUARTXnum(vdst, 8);
			QUARTChar('/');
			QUARTXnum(*srctmp, 8);
			dsttmp--;
			QUARTChar('-');
			QUARTXnum(*dsttmp, 8);
			dsttmp+=2;
			QUARTChar('+');
			QUARTXnum(*dsttmp, 8);
			dsttmp--;

			QUART_NEWLINE
		}

		dsttmp++;
		srctmp++;
	}
#endif

# if !defined(FPGA) && defined(SPCA6330)
	/* verifying DRAM contents */
	src = &_dram_content_lma_start;
	dst = &_dram_content_vma_start;
	while(dst < pimgend) {
		if (*dst != *src) {
			QUARTXnum((UINT32)dst, 8);
			QUARTChar('#');
			QUARTXnum((UINT32)src, 8);
			QUARTChar(':');
			QUARTXnum(*dst, 8);
			QUARTChar('(');
			QUARTXnum(*src, 8);
			QUARTChar(')');
			do {
				cpuDCacheFlush(dst, 4);
				*((UINT32 *)(0x20000000 | (UINT32)dst))
				= *((UINT32 *)(0x20000000 | (UINT32)src));
			} while (*dst != *src);
			QUARTXnum(*dst, 8);
			QUART_NEWLINE
		}
		dst++;
		src++;
	}
# endif /* #if !defined(FPGA) && defined(SPCA6330) */
#endif /*#ifndef RAM_PROGRAM*/

#if !MULTI_BOOT_STAGE
	/* Clear bss sections */
	dst = &_bssStart;
	while ( dst < &_bssEnd ) {
		*dst = 0;
		dst++;
	}
#endif /*!MULTI_BOOT_STAGE*/

#if SPCA6350

# if !DATA_ON_DMEM
#  if RAM_BOOT
	cpuCacheAllSyncI();
#  elif defined(RAM_PROGRAM)
#   if !MULTI_BOOT_STAGE
	cpuDCacheFlush(&_bssStart, (UINT8 *)&_bssEnd - (UINT8 *)&_bssStart);
#   endif
#  else
#   if !CPU_CORE_USE_ROM_INT_VECTOR
	cpuCacheSyncI(&_except, (UINT8 *)&_eexcept - (UINT8 *)&_except);
#   endif /*#if CPU_CORE_USE_ROM_INT_VECTOR*/
	cpuDCacheAllFlush();
#  endif
# endif /*#if !DATA_ON_DMEM*/

	memUnused = &_bottomOfHeap;
#if RAM_4GBIT_SUPPORT && DBG_RAM_4GBIT_SMALL_FW
	/* 4 Gbit DRAM using later half of 2 Gbit */
	memUnused += 256 * 1024 * 1024;
#endif /*#if RAM_4GBIT_SUPPORT && DBG_RAM_4GBIT_SMALL_FW*/
	__memUnusedSet(memUnused);

# if DATA_ON_DMEM
	pheapEnd   = (void *)SYS_DEAD_FRAME;
# else
	pheapEnd = (UINT8*)RAM_START_ADDR + memSize;

# endif
	__heapEndSet(pheapEnd);

#else  /*#if SPCA6350*/

	memProfile.pheapStart = (UINT8 *)&_bssEnd + 1024; /* Leave 1KB for sbrk */
	memProfile.pheapEnd   = (UINT8*)RAM_START_ADDR + memSize;
#endif /*#if SPCA6350*/

#if ISR_ON_IMEM
	{
		extern void halCpuImemIsrRefill()
# if !ROM_PROGRAM && !RAM_PROGRAM
					__attribute__((far))
# endif /*#if !ROM_PROGRAM && !RAM_PROGRAM*/
					;
		halCpuImemIsrRefill();
	}
#endif /*#if ISR_ON_IMEM*/
}


#if SPCA6350

UINT32
__addrIsText(
		const void *a
		)
{
	UINT32 *p = (UINT32 *)a;
# if RAM_BOOT
	return  (p >= &start && p < &_erom) ||
		(p >= &_text && p < &_ETEXT);
# else
	return  (p >= &start && p < &_ETEXT)
#  if ROM_PROGRAM && !CPU_CORE_USE_ROM_INT_VECTOR
		|| (p >= &_except && p < &_eexcept)
#  endif
		;
# endif
}

#else  /*#if SPCA6350*/

/**************************************************************************
 *                                                                        *
 *  Function Name: __heapEndGet                                           *
 *                                                                        *
 *  Purposes: Get the memory address of heap's end.                       *
 *                                                                        *
 *  Limitations:                                                          *
 *                                                                        *
 *  Arguments: None                                                       *
 *                                                                        *
 *  Returns: None                                                         *
 *                                                                        *
 *  See also:                                                             *
 *                                                                        *
 **************************************************************************/
void *
__heapEndGet(
	void
)
{
	return memProfile.pheapEnd;
}

#endif /*#if SPCA6350*/
